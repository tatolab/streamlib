// Example demonstrating the new PortRegistry macro
// This file is for documentation/testing purposes

use streamlib::{PortRegistry, StreamInput, StreamOutput, VideoFrame, AudioFrame};

// Define ports using the new macro
#[derive(PortRegistry)]
struct VideoProcessorPorts {
    #[input]
    video_in: StreamInput<VideoFrame>,

    #[input]
    audio_in: StreamInput<AudioFrame<2>>,

    #[output]
    video_out: StreamOutput<VideoFrame>,
}

// Example processor using the port registry
struct VideoProcessor {
    ports: VideoProcessorPorts,
    frame_count: u64,
}

impl VideoProcessor {
    fn new() -> Self {
        Self {
            ports: VideoProcessorPorts::new(),
            frame_count: 0,
        }
    }

    fn process(&mut self) {
        // Ergonomic port access via .inputs() and .outputs()
        if let Some(video_frame) = self.ports.inputs().video_in.read_latest() {
            // Process the frame...
            self.frame_count += 1;

            // Write to output
            self.ports.outputs().video_out.write(video_frame);
        }
    }

    // Port introspection methods (auto-generated by macro)
    fn get_port_info(&self) {
        // These methods are generated automatically
        let _video_in_type = self.ports.get_input_port_type("video_in");
        let _video_out_type = self.ports.get_output_port_type("video_out");
    }
}

// The macro generates:
// 1. VideoProcessorPortsInputPorts struct with video_in and audio_in fields
// 2. VideoProcessorPortsOutputPorts struct with video_out field
// 3. .inputs(), .inputs_mut(), .outputs(), .outputs_mut() methods
// 4. get_input_port_type(name) -> Option<PortType>
// 5. get_output_port_type(name) -> Option<PortType>
// 6. wire_input_connection(name, connection) -> bool
// 7. wire_output_connection(name, connection) -> bool

fn main() {
    let _processor = VideoProcessor::new();
    println!("PortRegistry example compiled successfully!");
}
