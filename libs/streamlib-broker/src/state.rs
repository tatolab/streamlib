// Copyright (c) 2025 Jonathan Fontanez
// SPDX-License-Identifier: BUSL-1.1

//! Thread-safe state for broker diagnostics.
//!
//! This module provides a separate state structure that tracks metadata
//! about registrations without storing XPC objects (raw pointers).
//! This allows safe sharing between the gRPC service and XPC listener.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::Instant;

use parking_lot::RwLock;

// ─────────────────────────────────────────────────────────────────────────────
// XPC Bridge Connection Types (Phase 4)
// ─────────────────────────────────────────────────────────────────────────────

/// Host processor state (tracked per-connection).
#[derive(Clone, Debug, PartialEq)]
pub enum HostState {
    /// Connection allocated, host hasn't contacted broker yet
    Pending,

    /// Host contacted broker via gRPC (HostAlive), but no XPC endpoint yet
    Alive,

    /// Host has stored XPC endpoint in broker via XPC message.
    /// Client can now retrieve it.
    XpcReady,

    /// Host has confirmed XPC connection works (received pong from client)
    Acked,

    /// Host failed (timeout, crashed, etc.)
    Failed(String),
}

impl HostState {
    /// Convert to string representation for gRPC responses.
    pub fn as_str(&self) -> &'static str {
        match self {
            HostState::Pending => "pending",
            HostState::Alive => "alive",
            HostState::XpcReady => "xpc_ready",
            HostState::Acked => "acked",
            HostState::Failed(_) => "failed",
        }
    }
}

/// Client processor state (tracked per-connection).
#[derive(Clone, Debug, PartialEq)]
pub enum ClientState {
    /// Subprocess spawned, hasn't contacted broker yet
    Pending,

    /// Client contacted broker via gRPC (ClientAlive)
    Alive,

    /// Client is polling for endpoint but hasn't received it yet
    /// (host_xpc_endpoint is still None)
    WaitingForEndpoint,

    /// Client has received the XPC endpoint from broker
    XpcEndpointReceived,

    /// Client has confirmed XPC connection works (sent pong to host)
    Acked,

    /// Client failed (timeout, crashed, etc.)
    Failed(String),
}

impl ClientState {
    /// Convert to string representation for gRPC responses.
    pub fn as_str(&self) -> &'static str {
        match self {
            ClientState::Pending => "pending",
            ClientState::Alive => "alive",
            ClientState::WaitingForEndpoint => "waiting_for_endpoint",
            ClientState::XpcEndpointReceived => "xpc_endpoint_received",
            ClientState::Acked => "acked",
            ClientState::Failed(_) => "failed",
        }
    }
}

/// Derived connection state computed from host and client states.
#[derive(Clone, Debug, PartialEq)]
pub enum DerivedConnectionState {
    /// Neither side has contacted broker yet
    AwaitingBoth,

    /// Host is alive, waiting for client subprocess to start
    AwaitingClient,

    /// Client is alive, waiting for host (unusual - host should be first)
    AwaitingHost,

    /// Both alive, but host hasn't stored XPC endpoint yet
    BothAliveAwaitingHostXpc,

    /// Host stored endpoint, client is polling to retrieve it
    ClientWaitingForHostEndpoint,

    /// Client has retrieved endpoint and is connecting
    ClientConnecting,

    /// Client connected, both sides doing ACK ping/pong
    AwaitingAck,

    /// Both ACKed - frames can flow!
    Ready,

    /// Something failed
    Failed,
}

impl DerivedConnectionState {
    /// Convert to string representation for gRPC responses.
    pub fn as_str(&self) -> &'static str {
        match self {
            DerivedConnectionState::AwaitingBoth => "awaiting_both",
            DerivedConnectionState::AwaitingClient => "awaiting_client",
            DerivedConnectionState::AwaitingHost => "awaiting_host",
            DerivedConnectionState::BothAliveAwaitingHostXpc => "both_alive_awaiting_host_xpc",
            DerivedConnectionState::ClientWaitingForHostEndpoint => {
                "client_waiting_for_host_endpoint"
            }
            DerivedConnectionState::ClientConnecting => "client_connecting",
            DerivedConnectionState::AwaitingAck => "awaiting_ack",
            DerivedConnectionState::Ready => "ready",
            DerivedConnectionState::Failed => "failed",
        }
    }
}

/// XPC Bridge Connection - Single source of truth for connection state.
///
/// Holds everything about a connection - gRPC state AND XPC endpoint.
/// Note: xpc_endpoint_t is stored separately in XpcEndpointStore (raw pointer
/// cannot be stored here safely across threads).
#[derive(Clone, Debug)]
pub struct XpcBridgeConnection {
    // ─────────────────────────────────────────────────────────────────
    // IDENTITY
    // ─────────────────────────────────────────────────────────────────
    /// Unique ID generated by broker on AllocateConnection
    pub connection_id: String,

    /// Runtime that owns this connection
    pub runtime_id: String,

    /// Processor within the runtime
    pub processor_id: String,

    // ─────────────────────────────────────────────────────────────────
    // HOST SIDE (Rust processor in runtime)
    // ─────────────────────────────────────────────────────────────────
    /// Current state of the host
    pub host_state: HostState,

    /// When host first contacted broker (gRPC: HostAlive)
    pub host_alive_at: Option<Instant>,

    /// Whether host XPC endpoint has been stored (via XPC message to broker).
    /// The actual endpoint is in XpcEndpointStore.
    pub host_xpc_endpoint_stored: bool,

    /// When the endpoint was stored (for debugging/metrics)
    pub host_xpc_endpoint_stored_at: Option<Instant>,

    /// When host confirmed ACK complete
    pub host_acked_at: Option<Instant>,

    /// Last time broker heard from host (heartbeat)
    pub host_last_seen: Instant,

    // ─────────────────────────────────────────────────────────────────
    // CLIENT SIDE (Python subprocess)
    // ─────────────────────────────────────────────────────────────────
    /// Current state of the client
    pub client_state: ClientState,

    /// When client first contacted broker (gRPC: ClientAlive)
    pub client_alive_at: Option<Instant>,

    /// Number of times client has polled for endpoint.
    /// Useful for debugging ("client polled 47 times before getting endpoint")
    pub client_endpoint_poll_count: u32,

    /// First time client requested the endpoint
    pub client_first_endpoint_request_at: Option<Instant>,

    /// Have we successfully delivered the endpoint to client?
    pub client_endpoint_delivered: bool,

    /// When we delivered the endpoint
    pub client_endpoint_delivered_at: Option<Instant>,

    /// When client confirmed ACK complete
    pub client_acked_at: Option<Instant>,

    /// Last time broker heard from client (heartbeat)
    pub client_last_seen: Instant,

    // ─────────────────────────────────────────────────────────────────
    // LIFECYCLE & TIMEOUTS
    // ─────────────────────────────────────────────────────────────────
    /// When connection was allocated
    pub created_at: Instant,

    /// When both sides acked - connection is READY, frames can flow
    pub ready_at: Option<Instant>,

    /// If connection failed
    pub failed_at: Option<Instant>,
    pub failure_reason: Option<String>,

    /// Timeout in seconds (default 300 = 5 min)
    pub timeout_secs: u64,
}

impl XpcBridgeConnection {
    /// Create a new connection with the given IDs.
    pub fn new(connection_id: String, runtime_id: String, processor_id: String) -> Self {
        let now = Instant::now();
        Self {
            connection_id,
            runtime_id,
            processor_id,
            host_state: HostState::Pending,
            host_alive_at: None,
            host_xpc_endpoint_stored: false,
            host_xpc_endpoint_stored_at: None,
            host_acked_at: None,
            host_last_seen: now,
            client_state: ClientState::Pending,
            client_alive_at: None,
            client_endpoint_poll_count: 0,
            client_first_endpoint_request_at: None,
            client_endpoint_delivered: false,
            client_endpoint_delivered_at: None,
            client_acked_at: None,
            client_last_seen: now,
            created_at: now,
            ready_at: None,
            failed_at: None,
            failure_reason: None,
            timeout_secs: 300, // 5 minutes default
        }
    }

    /// Derive the connection state from host and client states.
    pub fn derived_state(&self) -> DerivedConnectionState {
        // Check for failures first
        if matches!(self.host_state, HostState::Failed(_))
            || matches!(self.client_state, ClientState::Failed(_))
        {
            return DerivedConnectionState::Failed;
        }

        // Check for ready
        if self.ready_at.is_some() {
            return DerivedConnectionState::Ready;
        }

        // Both acked but ready_at not set yet?
        if matches!(self.host_state, HostState::Acked)
            && matches!(self.client_state, ClientState::Acked)
        {
            return DerivedConnectionState::Ready;
        }

        // Check for awaiting ack
        if matches!(self.client_state, ClientState::XpcEndpointReceived) {
            if matches!(self.host_state, HostState::Acked) {
                return DerivedConnectionState::AwaitingAck;
            }
            return DerivedConnectionState::ClientConnecting;
        }

        // Client waiting for endpoint
        if matches!(self.client_state, ClientState::WaitingForEndpoint) {
            return DerivedConnectionState::ClientWaitingForHostEndpoint;
        }

        // Host XPC ready, client alive
        if matches!(self.host_state, HostState::XpcReady)
            && matches!(self.client_state, ClientState::Alive)
        {
            return DerivedConnectionState::ClientWaitingForHostEndpoint;
        }

        // Both alive, awaiting host XPC
        if matches!(self.host_state, HostState::Alive)
            && matches!(self.client_state, ClientState::Alive)
        {
            return DerivedConnectionState::BothAliveAwaitingHostXpc;
        }

        // Host alive, client pending
        if matches!(self.host_state, HostState::Alive | HostState::XpcReady)
            && matches!(self.client_state, ClientState::Pending)
        {
            return DerivedConnectionState::AwaitingClient;
        }

        // Client alive, host pending (unusual)
        if matches!(self.host_state, HostState::Pending)
            && !matches!(self.client_state, ClientState::Pending)
        {
            return DerivedConnectionState::AwaitingHost;
        }

        // Default: awaiting both
        DerivedConnectionState::AwaitingBoth
    }

    /// Check if this connection has timed out.
    pub fn is_timed_out(&self) -> bool {
        // Already ready or failed - not timed out
        if self.ready_at.is_some() || self.failed_at.is_some() {
            return false;
        }

        self.created_at.elapsed().as_secs() > self.timeout_secs
    }

    /// Get the age of this connection in seconds.
    pub fn age_secs(&self) -> u64 {
        self.created_at.elapsed().as_secs()
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Existing Types (Phase 3 and earlier)
// ─────────────────────────────────────────────────────────────────────────────

/// Metadata about a registered runtime.
#[derive(Clone, Debug)]
pub struct RuntimeMetadata {
    pub runtime_id: String,
    pub name: String,
    pub api_endpoint: String,
    pub log_path: String,
    pub pid: i32,
    pub registered_at: Instant,
}

/// Metadata about a registered subprocess/processor.
#[derive(Clone, Debug)]
pub struct SubprocessMetadata {
    pub subprocess_key: String,
    pub runtime_id: String,
    pub processor_id: String,
    pub registered_at: Instant,
}

/// Metadata about an established connection.
#[derive(Clone, Debug)]
pub struct ConnectionMetadata {
    pub connection_id: String,
    pub runtime_id: String,
    pub processor_id: String,
    pub role: String,
    pub established_at: Instant,
}

/// Thread-safe state for broker diagnostics.
#[derive(Clone)]
pub struct BrokerState {
    inner: Arc<BrokerStateInner>,
}

struct BrokerStateInner {
    runtimes: RwLock<HashMap<String, RuntimeMetadata>>,
    subprocesses: RwLock<HashMap<String, SubprocessMetadata>>,
    connections: RwLock<HashMap<String, ConnectionMetadata>>,
    /// XPC bridge connections (Phase 4) - keyed by connection_id
    xpc_bridge_connections: RwLock<HashMap<String, XpcBridgeConnection>>,
    started_at: Instant,
    connection_counter: std::sync::atomic::AtomicU64,
    /// Counter for XPC bridge connection IDs
    xpc_bridge_connection_counter: std::sync::atomic::AtomicU64,
}

impl BrokerState {
    /// Create a new broker state.
    pub fn new() -> Self {
        Self {
            inner: Arc::new(BrokerStateInner {
                runtimes: RwLock::new(HashMap::new()),
                subprocesses: RwLock::new(HashMap::new()),
                connections: RwLock::new(HashMap::new()),
                xpc_bridge_connections: RwLock::new(HashMap::new()),
                started_at: Instant::now(),
                connection_counter: std::sync::atomic::AtomicU64::new(0),
                xpc_bridge_connection_counter: std::sync::atomic::AtomicU64::new(0),
            }),
        }
    }

    /// Get broker uptime in seconds.
    pub fn uptime_secs(&self) -> i64 {
        self.inner.started_at.elapsed().as_secs() as i64
    }

    /// Register a runtime with minimal metadata (legacy, for backwards compatibility).
    pub fn register_runtime(&self, runtime_id: &str) {
        self.register_runtime_with_metadata(runtime_id, runtime_id, "", "", 0);
    }

    /// Register a runtime with full metadata.
    pub fn register_runtime_with_metadata(
        &self,
        runtime_id: &str,
        name: &str,
        api_endpoint: &str,
        log_path: &str,
        pid: i32,
    ) {
        let metadata = RuntimeMetadata {
            runtime_id: runtime_id.to_string(),
            name: name.to_string(),
            api_endpoint: api_endpoint.to_string(),
            log_path: log_path.to_string(),
            pid,
            registered_at: Instant::now(),
        };
        self.inner
            .runtimes
            .write()
            .insert(runtime_id.to_string(), metadata);
    }

    /// Get a runtime by name.
    pub fn get_runtime_by_name(&self, name: &str) -> Option<RuntimeMetadata> {
        self.inner
            .runtimes
            .read()
            .values()
            .find(|r| r.name == name)
            .cloned()
    }

    /// Get a runtime by ID.
    pub fn get_runtime_by_id(&self, runtime_id: &str) -> Option<RuntimeMetadata> {
        self.inner.runtimes.read().get(runtime_id).cloned()
    }

    /// Unregister a runtime.
    pub fn unregister_runtime(&self, runtime_id: &str) {
        self.inner.runtimes.write().remove(runtime_id);
    }

    /// Get all registered runtimes.
    pub fn get_runtimes(&self) -> Vec<RuntimeMetadata> {
        self.inner.runtimes.read().values().cloned().collect()
    }

    /// Get runtime count.
    pub fn runtime_count(&self) -> usize {
        self.inner.runtimes.read().len()
    }

    /// Register a subprocess.
    pub fn register_subprocess(&self, subprocess_key: &str) {
        // Parse subprocess_key format: "runtime_id:processor_id"
        let parts: Vec<&str> = subprocess_key.splitn(2, ':').collect();
        let (runtime_id, processor_id) = if parts.len() == 2 {
            (parts[0].to_string(), parts[1].to_string())
        } else {
            (subprocess_key.to_string(), String::new())
        };

        let metadata = SubprocessMetadata {
            subprocess_key: subprocess_key.to_string(),
            runtime_id,
            processor_id,
            registered_at: Instant::now(),
        };
        self.inner
            .subprocesses
            .write()
            .insert(subprocess_key.to_string(), metadata);
    }

    /// Unregister a subprocess.
    pub fn unregister_subprocess(&self, subprocess_key: &str) {
        self.inner.subprocesses.write().remove(subprocess_key);
    }

    /// Get all registered subprocesses.
    pub fn get_subprocesses(&self) -> Vec<SubprocessMetadata> {
        self.inner.subprocesses.read().values().cloned().collect()
    }

    /// Get subprocesses for a specific runtime.
    pub fn get_subprocesses_for_runtime(&self, runtime_id: &str) -> Vec<SubprocessMetadata> {
        self.inner
            .subprocesses
            .read()
            .values()
            .filter(|s| s.runtime_id == runtime_id)
            .cloned()
            .collect()
    }

    /// Get subprocess count for a runtime.
    pub fn subprocess_count_for_runtime(&self, runtime_id: &str) -> usize {
        self.inner
            .subprocesses
            .read()
            .values()
            .filter(|s| s.runtime_id == runtime_id)
            .count()
    }

    /// Record a connection when an endpoint is retrieved.
    pub fn record_connection(&self, runtime_id: &str, processor_id: &str, role: &str) -> String {
        let counter = self
            .inner
            .connection_counter
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        let connection_id = format!("conn-{}", counter);

        let metadata = ConnectionMetadata {
            connection_id: connection_id.clone(),
            runtime_id: runtime_id.to_string(),
            processor_id: processor_id.to_string(),
            role: role.to_string(),
            established_at: Instant::now(),
        };
        self.inner
            .connections
            .write()
            .insert(connection_id.clone(), metadata);

        connection_id
    }

    /// Remove a connection.
    pub fn remove_connection(&self, connection_id: &str) {
        self.inner.connections.write().remove(connection_id);
    }

    /// Get all connections.
    pub fn get_connections(&self) -> Vec<ConnectionMetadata> {
        self.inner.connections.read().values().cloned().collect()
    }

    /// Get connections for a specific runtime.
    pub fn get_connections_for_runtime(&self, runtime_id: &str) -> Vec<ConnectionMetadata> {
        self.inner
            .connections
            .read()
            .values()
            .filter(|c| c.runtime_id == runtime_id)
            .cloned()
            .collect()
    }

    /// Get connection count for a runtime.
    pub fn connection_count_for_runtime(&self, runtime_id: &str) -> usize {
        self.inner
            .connections
            .read()
            .values()
            .filter(|c| c.runtime_id == runtime_id)
            .count()
    }

    // ─────────────────────────────────────────────────────────────────────────
    // XPC Bridge Connection Methods (Phase 4)
    // ─────────────────────────────────────────────────────────────────────────

    /// Allocate a new XPC bridge connection.
    /// Returns the connection_id.
    pub fn allocate_xpc_bridge_connection(&self, runtime_id: &str, processor_id: &str) -> String {
        let counter = self
            .inner
            .xpc_bridge_connection_counter
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        let connection_id = format!("xpc-conn-{}", counter);

        let connection = XpcBridgeConnection::new(
            connection_id.clone(),
            runtime_id.to_string(),
            processor_id.to_string(),
        );

        self.inner
            .xpc_bridge_connections
            .write()
            .insert(connection_id.clone(), connection);

        connection_id
    }

    /// Get an XPC bridge connection by ID.
    pub fn get_xpc_bridge_connection(&self, connection_id: &str) -> Option<XpcBridgeConnection> {
        self.inner
            .xpc_bridge_connections
            .read()
            .get(connection_id)
            .cloned()
    }

    /// Update an XPC bridge connection with a closure.
    /// Returns true if the connection was found and updated.
    pub fn update_xpc_bridge_connection<F>(&self, connection_id: &str, f: F) -> bool
    where
        F: FnOnce(&mut XpcBridgeConnection),
    {
        if let Some(conn) = self
            .inner
            .xpc_bridge_connections
            .write()
            .get_mut(connection_id)
        {
            f(conn);
            true
        } else {
            false
        }
    }

    /// Remove an XPC bridge connection.
    pub fn remove_xpc_bridge_connection(&self, connection_id: &str) -> Option<XpcBridgeConnection> {
        self.inner
            .xpc_bridge_connections
            .write()
            .remove(connection_id)
    }

    /// Get all XPC bridge connections.
    pub fn get_xpc_bridge_connections(&self) -> Vec<XpcBridgeConnection> {
        self.inner
            .xpc_bridge_connections
            .read()
            .values()
            .cloned()
            .collect()
    }

    /// Get timed out XPC bridge connection IDs.
    pub fn get_timed_out_xpc_bridge_connections(&self) -> Vec<String> {
        self.inner
            .xpc_bridge_connections
            .read()
            .iter()
            .filter(|(_, conn)| conn.is_timed_out())
            .map(|(id, _)| id.clone())
            .collect()
    }

    /// Prune dead runtimes by checking if their PIDs still exist.
    /// Returns the names of pruned runtimes.
    pub fn prune_dead_runtimes(&self) -> Vec<String> {
        let mut pruned = Vec::new();
        let mut runtimes = self.inner.runtimes.write();

        runtimes.retain(|_id, metadata| {
            let alive = is_process_alive(metadata.pid);
            if !alive {
                pruned.push(metadata.name.clone());
            }
            alive
        });

        pruned
    }
}

/// Check if a process is alive using kill(pid, 0).
/// Signal 0 doesn't send any signal - it just checks if the process exists.
fn is_process_alive(pid: i32) -> bool {
    if pid <= 0 {
        return false;
    }
    // SAFETY: kill with signal 0 is safe - it only checks process existence
    unsafe { libc::kill(pid, 0) == 0 }
}

impl Default for BrokerState {
    fn default() -> Self {
        Self::new()
    }
}
