// Copyright (c) 2025 Jonathan Fontanez
// SPDX-License-Identifier: BUSL-1.1

//! Rust code generation from schema definitions.

use crate::definition::{to_snake_case, Field, FieldType, SchemaDefinition};
use crate::error::Result;

/// Generate Rust code for a schema definition.
pub fn generate_rust(schema: &SchemaDefinition) -> Result<String> {
    let mut code = String::new();

    // File header
    code.push_str(&format!(
        r#"// Generated from {}
// DO NOT EDIT - regenerate with `streamlib schema sync`

use serde::{{Deserialize, Serialize}};

"#,
        schema.full_name()
    ));

    // Generate nested structs first (depth-first)
    let nested_structs =
        generate_nested_structs(schema, &schema.fields, &schema.rust_struct_name());
    code.push_str(&nested_structs);

    // Generate main struct
    let main_struct = generate_struct(schema, &schema.fields, &schema.rust_struct_name(), true);
    code.push_str(&main_struct);

    Ok(code)
}

/// Generate nested structs for object fields.
fn generate_nested_structs(
    schema: &SchemaDefinition,
    fields: &[Field],
    parent_name: &str,
) -> String {
    let mut code = String::new();

    for field in fields {
        if matches!(field.field_type, FieldType::Complex(ref s) if s.to_lowercase() == "object") {
            let nested_name = format!("{}{}", parent_name, to_pascal_case(&field.name));

            // Recursively generate any deeper nested structs
            let deeper_nested = generate_nested_structs(schema, &field.fields, &nested_name);
            code.push_str(&deeper_nested);

            // Generate this nested struct
            let nested_struct = generate_struct(schema, &field.fields, &nested_name, false);
            code.push_str(&nested_struct);
        }
    }

    code
}

/// Generate a single struct.
fn generate_struct(
    _schema: &SchemaDefinition,
    fields: &[Field],
    struct_name: &str,
    is_main: bool,
) -> String {
    let mut code = String::new();

    // Struct doc comment (only for main struct)
    if is_main {
        code.push_str(&format!("/// Schema: {}\n", struct_name));
    }

    // Derive attributes
    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    code.push_str(&format!("pub struct {} {{\n", struct_name));

    // Fields
    for field in fields {
        // Field doc comment
        if let Some(ref desc) = field.description {
            code.push_str(&format!("    /// {}\n", desc));
        }

        let field_name = to_snake_case(&field.name);
        let nested_struct_name = if matches!(field.field_type, FieldType::Complex(ref s) if s.to_lowercase() == "object")
        {
            Some(format!("{}{}", struct_name, to_pascal_case(&field.name)))
        } else {
            None
        };

        let rust_type = field.field_type.to_rust_type(nested_struct_name.as_deref());

        // Use serde rename if field name differs from original
        if field_name != field.name {
            code.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.name));
        }

        code.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
    }

    code.push_str("}\n\n");
    code
}

/// Convert string to PascalCase.
fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == '.' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate the mod.rs file for a collection of schemas.
pub fn generate_mod_rs(schemas: &[SchemaDefinition]) -> String {
    let mut code = String::new();

    code.push_str("// Generated by streamlib schema sync\n");
    code.push_str("// DO NOT EDIT\n\n");

    // Module declarations
    for schema in schemas {
        code.push_str(&format!("mod {};\n", schema.rust_module_name()));
    }

    code.push('\n');

    // Re-exports
    for schema in schemas {
        code.push_str(&format!(
            "pub use {}::{};\n",
            schema.rust_module_name(),
            schema.rust_struct_name()
        ));
    }

    code
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_yaml;

    #[test]
    fn test_generate_simple_struct() {
        let yaml = r#"
name: com.tatolab.videoframe
version: 1.0.0
description: "Video frame"

fields:
  - name: surface_id
    type: uint64
    description: "GPU surface ID"
  - name: width
    type: uint32
  - name: height
    type: uint32
  - name: timestamp_ns
    type: int64
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_rust(&schema).unwrap();

        assert!(code.contains("pub struct Videoframe"));
        assert!(code.contains("pub surface_id: u64"));
        assert!(code.contains("pub width: u32"));
        assert!(code.contains("pub timestamp_ns: i64"));
        assert!(code.contains("/// GPU surface ID"));
    }

    #[test]
    fn test_generate_nested_struct() {
        let yaml = r#"
name: com.example.detection
version: 1.0.0

fields:
  - name: label
    type: string
  - name: confidence
    type: float32
  - name: bounding_box
    type: object
    fields:
      - name: x
        type: uint32
      - name: y
        type: uint32
      - name: width
        type: uint32
      - name: height
        type: uint32
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_rust(&schema).unwrap();

        assert!(code.contains("pub struct Detection"));
        assert!(code.contains("pub struct DetectionBoundingBox"));
        assert!(code.contains("pub bounding_box: DetectionBoundingBox"));
    }

    #[test]
    fn test_generate_complex_types() {
        let yaml = r#"
name: com.example.complex
version: 1.0.0

fields:
  - name: tags
    type: array<string>
  - name: metadata
    type: map<string,int32>
  - name: optional_value
    type: optional<float64>
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_rust(&schema).unwrap();

        assert!(code.contains("pub tags: Vec<String>"));
        assert!(code.contains("pub metadata: std::collections::HashMap<String, i32>"));
        assert!(code.contains("pub optional_value: Option<f64>"));
    }

    #[test]
    fn test_generate_mod_rs() {
        let schemas = vec![
            parse_yaml(
                r#"
name: com.tatolab.videoframe
version: 1.0.0
"#,
            )
            .unwrap(),
            parse_yaml(
                r#"
name: com.tatolab.audioframe
version: 1.0.0
"#,
            )
            .unwrap(),
        ];

        let code = generate_mod_rs(&schemas);

        assert!(code.contains("mod com_tatolab_videoframe;"));
        assert!(code.contains("mod com_tatolab_audioframe;"));
        assert!(code.contains("pub use com_tatolab_videoframe::Videoframe;"));
        assert!(code.contains("pub use com_tatolab_audioframe::Audioframe;"));
    }
}
