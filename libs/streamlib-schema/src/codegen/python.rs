// Copyright (c) 2025 Jonathan Fontanez
// SPDX-License-Identifier: BUSL-1.1

//! Python code generation from schema definitions.

use crate::definition::{to_snake_case, Field, FieldType, SchemaDefinition};
use crate::error::Result;

/// Generate Python code for a schema definition.
pub fn generate_python(schema: &SchemaDefinition) -> Result<String> {
    let mut code = String::new();

    // File header
    code.push_str(&format!(
        r#"# Generated from {}
# DO NOT EDIT - regenerate with `streamlib schema sync`

import dataclasses
from dataclasses import dataclass
from typing import Optional, Any

import msgpack

"#,
        schema.full_name()
    ));

    // Generate nested classes first (depth-first)
    let nested_classes =
        generate_nested_classes(schema, &schema.fields, &schema.rust_struct_name());
    code.push_str(&nested_classes);

    // Generate main class
    let main_class = generate_class(schema, &schema.fields, &schema.rust_struct_name(), true);
    code.push_str(&main_class);

    Ok(code)
}

/// Generate nested classes for object fields.
fn generate_nested_classes(
    schema: &SchemaDefinition,
    fields: &[Field],
    parent_name: &str,
) -> String {
    let mut code = String::new();

    for field in fields {
        if matches!(field.field_type, FieldType::Complex(ref s) if s.to_lowercase() == "object") {
            let nested_name = format!("{}{}", parent_name, to_pascal_case(&field.name));

            // Recursively generate any deeper nested classes
            let deeper_nested = generate_nested_classes(schema, &field.fields, &nested_name);
            code.push_str(&deeper_nested);

            // Generate this nested class
            let nested_class = generate_class(schema, &field.fields, &nested_name, false);
            code.push_str(&nested_class);
        }
    }

    code
}

/// Generate a single dataclass.
fn generate_class(
    schema: &SchemaDefinition,
    fields: &[Field],
    class_name: &str,
    is_main: bool,
) -> String {
    let mut code = String::new();

    // Class doc comment (only for main class)
    if is_main {
        if let Some(ref desc) = schema.description {
            code.push_str(&format!("\"\"\"{}.\"\"\"\n", desc));
        }
    }

    // Dataclass decorator
    code.push_str("@dataclass\n");
    code.push_str(&format!("class {}:\n", class_name));

    if fields.is_empty() {
        code.push_str("    pass\n");
    } else {
        // Fields
        for field in fields {
            let field_name = to_snake_case(&field.name);
            let nested_class_name = if matches!(field.field_type, FieldType::Complex(ref s) if s.to_lowercase() == "object")
            {
                Some(format!("{}{}", class_name, to_pascal_case(&field.name)))
            } else {
                None
            };

            let python_type = field
                .field_type
                .to_python_type(nested_class_name.as_deref());

            // Field with type annotation
            if let Some(ref desc) = field.description {
                code.push_str(&format!("    \"\"\"{}.\"\"\"\n", desc));
            }
            code.push_str(&format!("    {}: {}\n", field_name, python_type));
        }
    }

    // Add msgpack methods
    code.push('\n');
    code.push_str(&format!(
        r#"    @classmethod
    def from_msgpack(cls, data: bytes) -> "{}":
        """Deserialize from MessagePack bytes."""
        d = msgpack.unpackb(data, raw=False)
        return cls(**d)

    def to_msgpack(self) -> bytes:
        """Serialize to MessagePack bytes."""
        return msgpack.packb(dataclasses.asdict(self))

"#,
        class_name
    ));

    code
}

/// Convert string to PascalCase.
fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == '.' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate the __init__.py file for a collection of schemas.
pub fn generate_init_py(schemas: &[SchemaDefinition]) -> String {
    let mut code = String::new();

    code.push_str("# Generated by streamlib schema sync\n");
    code.push_str("# DO NOT EDIT\n\n");

    // Imports
    for schema in schemas {
        let module_name = schema.rust_module_name();
        let class_name = schema.rust_struct_name();
        code.push_str(&format!("from .{} import {}\n", module_name, class_name));
    }

    code.push_str("\n__all__ = [\n");
    for schema in schemas {
        code.push_str(&format!("    \"{}\",\n", schema.rust_struct_name()));
    }
    code.push_str("]\n");

    code
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse_yaml;

    #[test]
    fn test_generate_simple_class() {
        let yaml = r#"
name: com.tatolab.videoframe
version: 1.0.0
description: "Video frame"

fields:
  - name: surface_id
    type: uint64
    description: "GPU surface ID"
  - name: width
    type: uint32
  - name: height
    type: uint32
  - name: timestamp_ns
    type: int64
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_python(&schema).unwrap();

        assert!(code.contains("@dataclass"));
        assert!(code.contains("class Videoframe:"));
        assert!(code.contains("surface_id: int"));
        assert!(code.contains("width: int"));
        assert!(code.contains("timestamp_ns: int"));
    }

    #[test]
    fn test_generate_nested_class() {
        let yaml = r#"
name: com.example.detection
version: 1.0.0

fields:
  - name: label
    type: string
  - name: confidence
    type: float32
  - name: bounding_box
    type: object
    fields:
      - name: x
        type: uint32
      - name: y
        type: uint32
      - name: width
        type: uint32
      - name: height
        type: uint32
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_python(&schema).unwrap();

        assert!(code.contains("class Detection:"));
        assert!(code.contains("class DetectionBoundingBox:"));
        assert!(code.contains("bounding_box: DetectionBoundingBox"));
    }

    #[test]
    fn test_generate_complex_types() {
        let yaml = r#"
name: com.example.complex
version: 1.0.0

fields:
  - name: tags
    type: array<string>
  - name: metadata
    type: map<string,int32>
  - name: optional_value
    type: optional<float64>
"#;

        let schema = parse_yaml(yaml).unwrap();
        let code = generate_python(&schema).unwrap();

        assert!(code.contains("tags: list[str]"));
        assert!(code.contains("metadata: dict[str, int]"));
        assert!(code.contains("optional_value: Optional[float]"));
    }

    #[test]
    fn test_generate_init_py() {
        let schemas = vec![
            parse_yaml(
                r#"
name: com.tatolab.videoframe
version: 1.0.0
"#,
            )
            .unwrap(),
            parse_yaml(
                r#"
name: com.tatolab.audioframe
version: 1.0.0
"#,
            )
            .unwrap(),
        ];

        let code = generate_init_py(&schemas);

        assert!(code.contains("from .com_tatolab_videoframe import Videoframe"));
        assert!(code.contains("from .com_tatolab_audioframe import Audioframe"));
        assert!(code.contains("__all__ = ["));
    }
}
