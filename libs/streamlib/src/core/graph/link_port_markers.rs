//! Link port marker traits for compile-time safe connections
//!
//! These traits are implemented by marker types generated by `#[derive(Processor)]`.
//! They enable the `output::<T>()` and `input::<T>()` helper functions for type-safe
//! graph links without magic strings.
//!
//! # Example
//!
//! ```ignore
//! use streamlib::{output, input};
//!
//! // Type-safe link - compiler verifies port exists
//! runtime.connect(
//!     output::<CameraProcessor::outputs::video>(&camera),
//!     input::<DisplayProcessor::inputs::video>(&display),
//! )?;
//! ```
//!
//! # How It Works
//!
//! The macro generates:
//! 1. Marker structs in `outputs` and `inputs` modules (e.g., `outputs::video`)
//! 2. Trait implementations that carry the port name as a const
//!
//! The helper functions use these traits to build `LinkPortRef` values with the
//! correct port name at compile time.

use super::link::LinkDirection;
use super::link_port_ref::LinkPortRef;
use super::node::ProcessorNode;

/// Marker trait for output ports
///
/// Implemented by marker types generated by `#[derive(Processor)]`.
/// The port name is stored as a const, enabling compile-time validation.
pub trait OutputPortMarker {
    /// The name of this output port (e.g., "video")
    const PORT_NAME: &'static str;

    /// The processor type this port belongs to
    type Processor;
}

/// Marker trait for input ports
///
/// Implemented by marker types generated by `#[derive(Processor)]`.
/// The port name is stored as a const, enabling compile-time validation.
pub trait InputPortMarker {
    /// The name of this input port (e.g., "video")
    const PORT_NAME: &'static str;

    /// The processor type this port belongs to
    type Processor;
}

/// Create a LinkPortRef for an output port using compile-time validated marker types
///
/// # Example
///
/// ```ignore
/// use streamlib::output;
///
/// let camera = runtime.add_processor::<CameraProcessor>(config)?;
///
/// // Compile-time validated: outputs::video must exist on CameraProcessor
/// let port_ref = output::<outputs::video>(&camera);
///
/// runtime.connect(
///     output::<outputs::video>(&camera),
///     input::<inputs::video>(&display),
/// )?;
/// ```
///
/// # Type Safety
///
/// If you try to use a non-existent port, you get a compile error:
/// ```ignore
/// output::<outputs::nonexistent>(&camera)  // Compile error!
/// ```
pub fn output<M: OutputPortMarker>(node: &ProcessorNode) -> LinkPortRef {
    LinkPortRef::output(node.id.clone(), M::PORT_NAME)
}

/// Create a LinkPortRef for an input port using compile-time validated marker types
///
/// # Example
///
/// ```ignore
/// use streamlib::input;
///
/// let display = runtime.add_processor::<DisplayProcessor>(config)?;
///
/// // Compile-time validated: inputs::video must exist on DisplayProcessor
/// runtime.connect(
///     output::<outputs::video>(&camera),
///     input::<inputs::video>(&display),
/// )?;
/// ```
pub fn input<M: InputPortMarker>(node: &ProcessorNode) -> LinkPortRef {
    LinkPortRef::input(node.id.clone(), M::PORT_NAME)
}

/// Wrapper trait that allows LinkPortRef creation from marker types
///
/// This enables marker types to implement `IntoLinkPortRef`.
pub trait PortMarker {
    /// The port name
    const PORT_NAME: &'static str;

    /// The direction (input or output)
    const DIRECTION: LinkDirection;
}

impl<M: OutputPortMarker> PortMarker for M {
    const PORT_NAME: &'static str = M::PORT_NAME;
    const DIRECTION: LinkDirection = LinkDirection::Output;
}

// Note: We can't implement PortMarker for InputPortMarker because of overlapping impls.
// The output<T>() and input<T>() functions handle this distinction instead.

#[cfg(test)]
mod tests {
    use super::*;

    // Mock processor for testing
    struct MockProcessor;

    // Mock output port marker
    struct MockVideoOutput;
    impl OutputPortMarker for MockVideoOutput {
        const PORT_NAME: &'static str = "video";
        type Processor = MockProcessor;
    }

    // Mock input port marker
    struct MockVideoInput;
    impl InputPortMarker for MockVideoInput {
        const PORT_NAME: &'static str = "video";
        type Processor = MockProcessor;
    }

    #[test]
    fn test_output_marker() {
        let node = ProcessorNode::new(
            "camera_0".to_string(),
            "MockProcessor".to_string(),
            None,
            vec![],
            vec![],
        );

        let port_ref = output::<MockVideoOutput>(&node);

        assert_eq!(port_ref.processor_id, "camera_0");
        assert_eq!(port_ref.port_name, "video");
        assert!(port_ref.is_output());
    }

    #[test]
    fn test_input_marker() {
        let node = ProcessorNode::new(
            "display_0".to_string(),
            "MockProcessor".to_string(),
            None,
            vec![],
            vec![],
        );

        let port_ref = input::<MockVideoInput>(&node);

        assert_eq!(port_ref.processor_id, "display_0");
        assert_eq!(port_ref.port_name, "video");
        assert!(port_ref.is_input());
    }
}
