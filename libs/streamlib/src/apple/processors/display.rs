use crate::core::{StreamInput, VideoFrame, Result, StreamError};
use crate::apple::{metal::MetalDevice, WgpuBridge};
use objc2::{rc::Retained, MainThreadMarker};
use objc2_foundation::{NSString, NSPoint, NSSize, NSRect};
use objc2_app_kit::{NSWindow, NSBackingStoreType, NSWindowStyleMask, NSApplication, NSApplicationActivationPolicy};
use objc2_quartz_core::{CAMetalLayer, CAMetalDrawable};
use objc2_metal::MTLPixelFormat;
use std::sync::{atomic::{AtomicU64, AtomicUsize, Ordering}, Arc};
use metal;
use streamlib_macros::StreamProcessor;

// Apple-specific configuration and types
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppleDisplayConfig {
    pub width: u32,
    pub height: u32,
    pub title: Option<String>,
}

impl Default for AppleDisplayConfig {
    fn default() -> Self {
        Self {
            width: 1920,
            height: 1080,
            title: None,
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Default)]
pub struct AppleWindowId(pub u64);

static NEXT_WINDOW_ID: AtomicU64 = AtomicU64::new(1);

#[derive(StreamProcessor)]
#[processor(
    mode = Push,
    description = "Displays video frames in a window using Metal",
    unsafe_send
)]
pub struct AppleDisplayProcessor {
    #[input(description = "Video frames to display in the window")]
    video: StreamInput<VideoFrame>,

    #[config]
    config: AppleDisplayConfig,

    // Runtime state fields - auto-detected (no attribute needed)
    window: Option<Retained<NSWindow>>,
    metal_layer: Option<Retained<CAMetalLayer>>,
    layer_addr: Arc<AtomicUsize>,
    metal_device: Option<MetalDevice>,
    metal_command_queue: Option<metal::CommandQueue>,
    gpu_context: Option<crate::core::GpuContext>,
    wgpu_bridge: Option<Arc<WgpuBridge>>,
    window_id: AppleWindowId,
    window_title: String,
    width: u32,
    height: u32,
    frames_rendered: u64,
    window_creation_dispatched: bool,
}

// SAFETY: NSWindow, CAMetalLayer, and Metal objects are Objective-C objects that can be sent between threads
// Retained<T> types use Arc-like reference counting and are safe to send
// unsafe impl Send auto-generated by StreamProcessor macro with unsafe_send attribute

// Business logic - all trait methods auto-generated by macro!
impl AppleDisplayProcessor {
    // Lifecycle - auto-detected by macro
    fn on_start(&mut self, ctx: &crate::core::RuntimeContext) -> Result<()> {
        self.gpu_context = Some(ctx.gpu.clone());
        self.window_id = AppleWindowId(NEXT_WINDOW_ID.fetch_add(1, Ordering::SeqCst));
        self.width = self.config.width;
        self.height = self.config.height;
        self.window_title = self.config.title.clone().unwrap_or_else(|| "streamlib Display".to_string());

        let metal_device = MetalDevice::new()?;

        // Create metal crate command queue from objc2 Metal device
        let metal_command_queue = {
            use metal::foreign_types::ForeignTypeRef;
            let device_ptr = metal_device.device() as *const _ as *mut std::ffi::c_void;
            let metal_device_ref = unsafe {
                metal::DeviceRef::from_ptr(device_ptr as *mut _)
            };
            metal_device_ref.new_command_queue()
        };

        // Create wgpu bridge from shared device
        let wgpu_bridge = Arc::new(WgpuBridge::from_shared_device(
            metal_device.clone_device(),
            ctx.gpu.device().as_ref().clone(),
            ctx.gpu.queue().as_ref().clone(),
        ));

        self.wgpu_bridge = Some(wgpu_bridge);
        self.metal_command_queue = Some(metal_command_queue);
        self.metal_device = Some(metal_device);

        tracing::info!("Display {}: Initialized ({}x{})", self.window_title, self.width, self.height);
        Ok(())
    }

    fn on_stop(&mut self) -> Result<()> {
        tracing::info!("Display {}: Stopping (rendered {} frames)", self.window_title, self.frames_rendered);
        Ok(())
    }

    // Business logic - called by macro-generated process()
    fn process(&mut self) -> Result<()> {
        if let Some(frame) = self.video.read_latest() {
            self.render_frame(frame)?;
        }
        Ok(())
    }

    // Helper methods
    pub fn window_id(&self) -> AppleWindowId {
        self.window_id
    }

    pub fn set_window_title(&mut self, title: &str) {
        self.window_title = title.to_string();
        if let Some(window) = &self.window {
            let title_string = NSString::from_str(title);
            window.setTitle(&title_string);
        }
    }

    fn render_frame(&mut self, frame: VideoFrame) -> Result<()> {
        // Lazy window creation on first frame
        if !self.window_creation_dispatched {
            self.initialize_window()?;
        }

        let wgpu_texture = &frame.texture;

        let wgpu_bridge = self.wgpu_bridge.as_ref()
            .ok_or_else(|| StreamError::Configuration("WgpuBridge not initialized".into()))?;

        let source_metal = unsafe {
            wgpu_bridge.unwrap_to_metal_texture(wgpu_texture)
        }?;

        let layer_addr = self.layer_addr.load(Ordering::Acquire);
        if layer_addr == 0 {
            return Ok(());
        }

        // SAFETY: Layer was created on main thread and address stored atomically
        let metal_layer = unsafe {
            let ptr = layer_addr as *const CAMetalLayer;
            &*ptr
        };

        let metal_command_queue = self.metal_command_queue.as_ref()
            .ok_or_else(|| StreamError::Configuration("Metal command queue not initialized".into()))?;

        unsafe {
            if let Some(drawable) = metal_layer.nextDrawable() {
                let drawable_metal = drawable.texture();

                use metal::foreign_types::ForeignTypeRef;
                let drawable_texture_ptr = &*drawable_metal as *const _ as *mut std::ffi::c_void;
                let drawable_metal_ref = metal::TextureRef::from_ptr(drawable_texture_ptr as *mut _);

                let drawable_ptr = &*drawable as *const _ as *mut std::ffi::c_void;
                let drawable_ref = metal::DrawableRef::from_ptr(drawable_ptr as *mut _);

                let command_buffer = metal_command_queue.new_command_buffer();
                let blit_encoder = command_buffer.new_blit_command_encoder();

                use metal::MTLOrigin;
                use metal::MTLSize;

                let origin = MTLOrigin { x: 0, y: 0, z: 0 };
                let size = MTLSize {
                    width: frame.width as u64,
                    height: frame.height as u64,
                    depth: 1,
                };

                blit_encoder.copy_from_texture(
                    &source_metal,
                    0,
                    0,
                    origin,
                    size,
                    drawable_metal_ref,
                    0,
                    0,
                    origin,
                );

                blit_encoder.end_encoding();

                command_buffer.present_drawable(drawable_ref);
                command_buffer.commit();

                self.frames_rendered += 1;

                if self.frames_rendered.is_multiple_of(60) {
                    tracing::info!(
                        "Display {}: Rendered frame {} ({}x{}) via Metal blit",
                        self.window_id.0,
                        frame.frame_number,
                        frame.width,
                        frame.height
                    );
                }
            }
        }

        Ok(())
    }

    fn initialize_window(&mut self) -> Result<()> {
        let width = self.width;
        let height = self.height;
        let window_title = self.window_title.clone();
        let metal_device = self.metal_device.as_ref()
            .ok_or_else(|| StreamError::Configuration("Metal device not initialized".into()))?
            .clone_device();
        let window_id = self.window_id;
        let layer_addr = Arc::clone(&self.layer_addr);

        use dispatch2::DispatchQueue;

        DispatchQueue::main().exec_async(move || {
            // SAFETY: This closure executes on the main thread via GCD
            let mtm = unsafe { MainThreadMarker::new_unchecked() };

            tracing::info!("Display {}: Creating window on main thread...", window_id.0);

            let frame = NSRect::new(
                NSPoint::new(100.0, 100.0),
                NSSize::new(width as f64, height as f64),
            );

            let style_mask = NSWindowStyleMask::Titled
                | NSWindowStyleMask::Closable
                | NSWindowStyleMask::Miniaturizable
                | NSWindowStyleMask::Resizable;

            let window = unsafe {
                NSWindow::initWithContentRect_styleMask_backing_defer(
                    mtm.alloc(),
                    frame,
                    style_mask,
                    NSBackingStoreType::Buffered,
                    false,
                )
            };

            window.setTitle(&NSString::from_str(&window_title));

            let metal_layer = CAMetalLayer::new();
            metal_layer.setDevice(Some(&metal_device));
            metal_layer.setPixelFormat(MTLPixelFormat::BGRA8Unorm);

            unsafe {
                use objc2::{msg_send, Encode, Encoding};

                #[repr(C)]
                struct CGSize {
                    width: f64,
                    height: f64,
                }

                unsafe impl Encode for CGSize {
                    const ENCODING: Encoding = Encoding::Struct("CGSize", &[f64::ENCODING, f64::ENCODING]);
                }

                let size = CGSize {
                    width: width as f64,
                    height: height as f64,
                };

                let _: () = msg_send![&metal_layer, setDrawableSize: size];
            }

            if let Some(content_view) = window.contentView() {
                content_view.setWantsLayer(true);
                content_view.setLayer(Some(&metal_layer));
            }

            window.makeKeyAndOrderFront(None);

            let app = NSApplication::sharedApplication(mtm);
            app.setActivationPolicy(NSApplicationActivationPolicy::Regular);
            app.activateIgnoringOtherApps(true);

            let _ = Retained::into_raw(window);  // Leak window
            let addr = Retained::into_raw(metal_layer) as usize;
            layer_addr.store(addr, Ordering::Release);
        });

        self.window_creation_dispatched = true;
        tracing::info!("Display {}: Window creation dispatched, processor ready", self.window_id.0);

        Ok(())
    }
}

crate::register_processor_type!(AppleDisplayProcessor);
