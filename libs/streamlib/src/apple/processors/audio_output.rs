use crate::core::{StreamInput, Result, StreamError};
use crate::core::frames::AudioFrame;
use streamlib_macros::StreamProcessor;
use cpal::Stream;
use cpal::traits::StreamTrait;
use std::sync::Arc;

// Apple-specific configuration and device types
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppleAudioOutputConfig {
    pub device_id: Option<String>,
}

impl Default for AppleAudioOutputConfig {
    fn default() -> Self {
        Self { device_id: None }
    }
}

#[derive(Debug, Clone)]
pub struct AppleAudioDevice {
    pub id: usize,
    pub name: String,
    pub sample_rate: u32,
    pub channels: u32,
    pub is_default: bool,
}

#[derive(StreamProcessor)]
#[processor(
    mode = Pull,
    description = "Plays audio through speakers/headphones using CoreAudio",
    unsafe_send
)]
pub struct AppleAudioOutputProcessor {
    #[input(description = "Stereo audio frame to play through speakers")]
    audio: Arc<StreamInput<AudioFrame<2>>>,

    #[config]
    config: AppleAudioOutputConfig,

    // Runtime state fields - auto-detected (no attribute needed)
    device_id: Option<usize>,
    device_name: String,
    device_info: Option<AppleAudioDevice>,
    stream: Option<Stream>,
    stream_setup_done: bool,
    sample_rate: u32,
    channels: u32,
    buffer_size: usize,
}

// SAFETY: cpal::Stream is not Send, but AppleAudioOutputProcessor is safe to send between threads
// because cpal streams handle thread-safety internally via platform audio APIs
// unsafe impl Send auto-generated by StreamProcessor macro with unsafe_send attribute

// Only business logic - all trait methods auto-generated by macro!
impl AppleAudioOutputProcessor {
    // Lifecycle - auto-detected by macro
    fn setup(&mut self, _ctx: &crate::core::RuntimeContext) -> Result<()> {
        self.device_id = self.config.device_id.as_ref().and_then(|s| s.parse::<usize>().ok());
        tracing::info!("AudioOutput: start() called (Pull mode - will query device for native config)");
        Ok(())
    }

    fn teardown(&mut self) -> Result<()> {
        self.stream = None;
        tracing::info!("AudioOutput {}: Stopped", self.device_name);
        Ok(())
    }

    // Business logic - called by macro-generated process()
    fn process(&mut self) -> Result<()> {
        if self.stream_setup_done {
            return Ok(());
        }

        tracing::info!("AudioOutput: process() called - setting up stream now that connections are wired");

        // Query hardware device for native sample_rate and buffer_size
        use cpal::traits::{DeviceTrait, HostTrait};

        let host = cpal::default_host();
        let device = if let Some(id) = self.device_id {
            let devices: Vec<_> = host
                .output_devices()
                .map_err(|e| StreamError::Configuration(format!("Failed to enumerate audio devices: {}", e)))?
                .collect();
            devices
                .get(id)
                .ok_or_else(|| StreamError::Configuration(format!("Audio device {} not found", id)))?
                .clone()
        } else {
            host.default_output_device()
                .ok_or_else(|| StreamError::Configuration("No default audio output device".into()))?
        };

        let device_config = device
            .default_output_config()
            .map_err(|e| StreamError::Configuration(format!("Failed to get audio config: {}", e)))?;

        let device_sample_rate = device_config.sample_rate().0;
        let device_channels = device_config.channels() as u32;

        // Query the device's preferred buffer size
        let device_buffer_size = match device_config.buffer_size() {
            cpal::SupportedBufferSize::Range { min: _, max } => *max as usize,
            cpal::SupportedBufferSize::Unknown => 512, // Fallback to reasonable default
        };

        tracing::info!(
            "AudioOutput: Queried device config - {}Hz, {} channels, {} buffer size",
            device_sample_rate,
            device_channels,
            device_buffer_size
        );

        // Clone the Arc-wrapped port for the audio callback thread
        let audio_port = Arc::clone(&self.audio);

        tracing::info!("AudioOutput: Cloned audio port for callback thread");

        tracing::info!("AudioOutput: Setting up audio output with cpal");

        // Buffer for accumulating frames when device wants larger buffers than we provide
        let mut frame_buffer: Vec<f32> = Vec::new();

        let setup = crate::apple::audio_utils::setup_audio_output(
            self.device_id,
            device_buffer_size,
            move |data: &mut [f32], _info: &cpal::OutputCallbackInfo| {
                // Device may request more data than our frame size (e.g., 1920 samples when we provide 1024)
                // Accumulate frames until we have enough to fill the device buffer

                while frame_buffer.len() < data.len() {
                    if let Some(audio_frame) = audio_port.read() {
                        frame_buffer.extend_from_slice(&audio_frame.samples);
                    } else {
                        // No more frames available - break and use what we have
                        break;
                    }
                }

                if frame_buffer.len() >= data.len() {
                    // We have enough data - copy and remove from buffer
                    data.copy_from_slice(&frame_buffer[..data.len()]);
                    frame_buffer.drain(..data.len());
                } else if !frame_buffer.is_empty() {
                    // We have some data but not enough - copy what we have and pad with silence
                    let copy_len = frame_buffer.len();
                    data[..copy_len].copy_from_slice(&frame_buffer);
                    data[copy_len..].fill(0.0);
                    frame_buffer.clear();
                } else {
                    // No data at all - output silence
                    data.fill(0.0);
                }
            }
        )?;

        tracing::info!("AudioOutput: Starting cpal stream playback");
        setup.stream.play()
            .map_err(|e| StreamError::Configuration(format!("Failed to start stream: {}", e)))?;

        tracing::info!("AudioOutput: cpal stream.play() succeeded");

        self.stream = Some(setup.stream);
        self.device_name = setup.device_info.name.clone();
        self.device_info = Some(setup.device_info);
        self.sample_rate = setup.sample_rate;
        self.channels = setup.channels;
        self.buffer_size = device_buffer_size;
        self.stream_setup_done = true;

        tracing::info!(
            "AudioOutput {}: Stream setup complete ({}Hz, {} channels, {} buffer size, Pull mode)",
            self.device_name,
            self.sample_rate,
            self.channels,
            self.buffer_size
        );

        Ok(())
    }
}

