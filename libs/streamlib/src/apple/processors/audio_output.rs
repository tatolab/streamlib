use crate::core::{AudioDevice, StreamInput, Result, StreamError};
use crate::core::frames::AudioFrame;
use streamlib_macros::StreamProcessor;
use cpal::Stream;
use cpal::traits::StreamTrait;
use std::sync::Arc;

#[derive(StreamProcessor)]
#[processor(
    mode = Pull,
    description = "Plays audio through speakers/headphones using CoreAudio"
)]
pub struct AppleAudioOutputProcessor {
    #[input(description = "Stereo audio frame to play through speakers")]
    audio: Arc<StreamInput<AudioFrame<2>>>,

    #[config]
    config: crate::core::AudioOutputConfig,

    // Runtime state fields - auto-detected (no attribute needed)
    device_id: Option<usize>,
    device_name: String,
    device_info: Option<AudioDevice>,
    stream: Option<Stream>,
    stream_setup_done: bool,
    sample_rate: u32,
    channels: u32,
    buffer_size: usize,
}

unsafe impl Send for AppleAudioOutputProcessor {}

// Only business logic - all trait methods auto-generated by macro!
impl AppleAudioOutputProcessor {
    // Lifecycle - auto-detected by macro
    fn on_start(&mut self, ctx: &crate::core::RuntimeContext) -> Result<()> {
        self.buffer_size = ctx.audio.buffer_size;
        self.device_id = self.config.device_id.as_ref().and_then(|s| s.parse::<usize>().ok());
        tracing::info!("AudioOutput: start() called (Pull mode - buffer_size: {})", self.buffer_size);
        Ok(())
    }

    fn on_stop(&mut self) -> Result<()> {
        self.stream = None;
        tracing::info!("AudioOutput {}: Stopped", self.device_name);
        Ok(())
    }

    // Business logic - called by macro-generated process()
    fn process(&mut self) -> Result<()> {
        if self.stream_setup_done {
            return Ok(());
        }

        tracing::info!("AudioOutput: process() called - setting up stream now that connections are wired");

        // Clone the Arc-wrapped port for the audio callback thread
        let audio_port = Arc::clone(&self.audio);

        tracing::info!("AudioOutput: Cloned audio port for callback thread");

        tracing::info!("AudioOutput: Setting up audio output with cpal");

        let setup = crate::apple::audio_utils::setup_audio_output(
            self.device_id,
            self.buffer_size,
            move |data: &mut [f32], _info: &cpal::OutputCallbackInfo| {
                // Lock-free read_latest() call
                if let Some(audio_frame) = audio_port.read_latest() {
                    let samples = &audio_frame.samples;

                    tracing::debug!("AudioOutput: Got audio frame with {} samples", samples.len());

                    let copy_len = data.len().min(samples.len());
                    data[..copy_len].copy_from_slice(&samples[..copy_len]);

                    if copy_len < data.len() {
                        data[copy_len..].fill(0.0);
                    }
                } else {
                    tracing::debug!("AudioOutput: No data available, outputting silence");
                    data.fill(0.0);
                }
            }
        )?;

        tracing::info!("AudioOutput: Starting cpal stream playback");
        setup.stream.play()
            .map_err(|e| StreamError::Configuration(format!("Failed to start stream: {}", e)))?;

        tracing::info!("AudioOutput: cpal stream.play() succeeded");

        self.stream = Some(setup.stream);
        self.device_name = setup.device_info.name.clone();
        self.device_info = Some(setup.device_info);
        self.sample_rate = setup.sample_rate;
        self.channels = setup.channels;
        self.stream_setup_done = true;

        tracing::info!(
            "AudioOutput {}: Stream setup complete ({}Hz, {} channels, Pull mode)",
            self.device_name,
            self.sample_rate,
            self.channels
        );

        Ok(())
    }
}

impl crate::core::AudioOutputProcessor for AppleAudioOutputProcessor {
    fn new(device_id: Option<usize>) -> Result<Self> {
        // Use from_config with appropriate config
        Self::from_config(crate::core::AudioOutputConfig {
            device_id: device_id.map(|id| id.to_string()),
        })
    }

    fn list_devices() -> Result<Vec<AudioDevice>> {
        // TODO: Implement device enumeration
        Ok(vec![])
    }

    fn current_device(&self) -> &AudioDevice {
        self.device_info.as_ref().unwrap_or_else(|| {
            // Return a default device info if not initialized
            static DEFAULT: AudioDevice = AudioDevice {
                id: 0,
                name: String::new(),
                sample_rate: 48000,
                channels: 2,
                is_default: true,
            };
            &DEFAULT
        })
    }
}
