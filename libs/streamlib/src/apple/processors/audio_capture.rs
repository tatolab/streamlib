use crate::core::{AudioFrame, Result, StreamError, StreamOutput};
use streamlib_macros::StreamProcessor;
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{Device, Stream, StreamConfig};
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::Arc;
use parking_lot::Mutex;

// Apple-specific configuration and device types
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppleAudioCaptureConfig {
    pub device_id: Option<String>,
    pub sample_rate: u32,
    pub channels: u32,
}

impl Default for AppleAudioCaptureConfig {
    fn default() -> Self {
        Self {
            device_id: None,
            sample_rate: 48000,
            channels: 2,
        }
    }
}

#[derive(Debug, Clone)]
pub struct AppleAudioInputDevice {
    pub id: usize,
    pub name: String,
    pub sample_rate: u32,
    pub channels: u32,
    pub is_default: bool,
}

#[derive(StreamProcessor)]
#[processor(
    mode = Pull,
    description = "Captures mono audio from macOS microphones using CoreAudio",
    unsafe_send
)]
pub struct AppleAudioCaptureProcessor {
    #[output(description = "Captured mono audio frames from the microphone")]
    audio: StreamOutput<AudioFrame<1>>,

    #[config]
    config: AppleAudioCaptureConfig,

    // Runtime state fields - auto-detected (no attribute needed)
    device_info: Option<AppleAudioInputDevice>,
    _device: Option<Device>,
    _stream: Option<Stream>,
    sample_buffer: Arc<Mutex<Vec<f32>>>,
    is_capturing: Arc<AtomicBool>,
    current_level: Arc<Mutex<f32>>,
    frame_counter: Arc<AtomicU64>,
    sample_rate: u32,
    channels: u32,
    wakeup_tx: Arc<Mutex<Option<crossbeam_channel::Sender<crate::core::runtime::WakeupEvent>>>>,
}

// SAFETY: cpal::Stream and cpal::Device are not Send, but AppleAudioCaptureProcessor is safe to send
// between threads because cpal handles thread-safety internally via platform audio APIs
// unsafe impl Send auto-generated by StreamProcessor macro with unsafe_send attribute

// Business logic - all trait methods auto-generated by macro!
impl AppleAudioCaptureProcessor {
    // Lifecycle - auto-detected by macro
    fn setup(&mut self, _ctx: &crate::core::RuntimeContext) -> Result<()> {
        self.sample_rate = self.config.sample_rate;
        self.channels = self.config.channels;

        let device_id = self.config.device_id.as_ref().and_then(|s| s.parse::<usize>().ok());

        let host = cpal::default_host();

        let device = if let Some(id) = device_id {
            let devices: Vec<_> = host
                .input_devices()
                .map_err(|e| StreamError::Configuration(format!("Failed to enumerate audio input devices: {}", e)))?
                .collect();
            devices
                .get(id)
                .ok_or_else(|| StreamError::Configuration(format!("Audio input device {} not found", id)))?
                .clone()
        } else {
            host.default_input_device()
                .ok_or_else(|| StreamError::Configuration("No default audio input device".into()))?
        };

        let device_name = device
            .name()
            .unwrap_or_else(|_| "Unknown Device".to_string());

        let default_config = device
            .default_input_config()
            .map_err(|e| StreamError::Configuration(format!("Failed to get audio config: {}", e)))?;

        let device_sample_rate = default_config.sample_rate().0;
        let device_channels = default_config.channels() as u32;

        tracing::info!(
            "Audio input device: {} ({}Hz, {} channels, requesting {}Hz {} channels)",
            device_name,
            device_sample_rate,
            device_channels,
            self.sample_rate,
            self.channels
        );

        let device_info = AppleAudioInputDevice {
            id: device_id.unwrap_or(0),
            name: device_name.clone(),
            sample_rate: device_sample_rate,
            channels: device_channels,
            is_default: device_id.is_none(),
        };

        let sample_buffer_clone = self.sample_buffer.clone();
        let is_capturing_clone = self.is_capturing.clone();
        let current_level_clone = self.current_level.clone();
        let wakeup_tx_clone = self.wakeup_tx.clone();

        let stream_config = StreamConfig {
            channels: self.channels as u16,
            sample_rate: cpal::SampleRate(self.sample_rate),
            buffer_size: cpal::BufferSize::Default,
        };

        let stream = device
            .build_input_stream(
                &stream_config,
                move |data: &[f32], _: &cpal::InputCallbackInfo| {
                    let mut buffer = sample_buffer_clone.lock();
                    buffer.extend_from_slice(data);

                    let peak = data.iter().map(|s| s.abs()).fold(0.0f32, f32::max);
                    *current_level_clone.lock() = peak;

                    is_capturing_clone.store(true, Ordering::Relaxed);

                    if let Some(tx) = wakeup_tx_clone.lock().as_ref() {
                        let _ = tx.send(crate::core::runtime::WakeupEvent::DataAvailable);
                    }
                },
                move |err| {
                    tracing::error!("Audio capture error: {}", err);
                },
                None,
            )
            .map_err(|e| StreamError::Configuration(format!("Failed to build audio stream: {}", e)))?;

        stream
            .play()
            .map_err(|e| StreamError::Configuration(format!("Failed to start audio stream: {}", e)))?;

        self.device_info = Some(device_info);
        self._device = Some(device);
        self._stream = Some(stream);

        tracing::info!("AudioCapture {}: Started ({}Hz, {} channels)", device_name, self.sample_rate, self.channels);
        Ok(())
    }

    fn teardown(&mut self) -> Result<()> {
        let device_name = self.device_info.as_ref().map(|d| d.name.as_str()).unwrap_or("Unknown");
        tracing::info!("AudioCapture {}: Stopping (captured {} frames)", device_name, self.frame_counter.load(Ordering::Relaxed));
        self._stream = None;
        self._device = None;
        Ok(())
    }

    // Business logic - called by macro-generated process()
    fn process(&mut self) -> Result<()> {
        let samples = {
            let mut buffer = self.sample_buffer.lock();

            let min_chunk_size = 512 * self.channels as usize;

            if buffer.len() >= min_chunk_size {
                let samples: Vec<f32> = buffer.drain(..).collect();
                samples
            } else {
                return Err(StreamError::Runtime(
                    format!("Not enough samples available ({} < {})", buffer.len(), min_chunk_size)
                ));
            }
        };

        let frame_number = self.frame_counter.fetch_add(1, Ordering::Relaxed);
        let timestamp_ns = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as i64;

        let mono_samples: Vec<f32> = if self.channels == 2 {
            samples.chunks_exact(2)
                .map(|chunk| (chunk[0] + chunk[1]) / 2.0)
                .collect()
        } else {
            samples
        };

        let frame = AudioFrame::<1>::new(
            mono_samples,
            timestamp_ns,
            frame_number,
        );

        self.audio.write(frame);
        Ok(())
    }

    // Helper methods
    pub fn list_devices() -> Result<Vec<AppleAudioInputDevice>> {
        let host = cpal::default_host();
        let devices: Result<Vec<AppleAudioInputDevice>> = host
            .input_devices()
            .map_err(|e| StreamError::Configuration(format!("Failed to enumerate audio input devices: {}", e)))?
            .enumerate()
            .map(|(id, device)| {
                let name = device.name().unwrap_or_else(|_| "Unknown Device".to_string());

                let config = device
                    .default_input_config()
                    .map_err(|e| StreamError::Configuration(format!("Failed to get device config: {}", e)))?;

                let sample_rate = config.sample_rate().0;
                let channels = config.channels() as u32;

                let is_default = if let Some(default_device) = host.default_input_device() {
                    device.name().ok() == default_device.name().ok()
                } else {
                    false
                };

                Ok(AppleAudioInputDevice {
                    id,
                    name,
                    sample_rate,
                    channels,
                    is_default,
                })
            })
            .collect();

        devices
    }

    pub fn current_device(&self) -> Option<&AppleAudioInputDevice> {
        self.device_info.as_ref()
    }

    pub fn current_level(&self) -> f32 {
        *self.current_level.lock()
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::traits::StreamProcessor;

    #[test]
    fn test_list_devices() {
        let devices = AppleAudioCaptureProcessor::list_devices();

        assert!(devices.is_ok());

        if let Ok(devices) = devices {
            println!("Found {} audio input devices:", devices.len());
            for device in &devices {
                println!(
                    "  [{}] {}: {}Hz, {} channels{}",
                    device.id,
                    device.name,
                    device.sample_rate,
                    device.channels,
                    if device.is_default { " (default)" } else { "" }
                );
            }

            assert!(devices.len() > 0, "Expected at least one audio input device");
        }
    }

    #[test]
    fn test_create_default_device() {
        let config = AppleAudioCaptureConfig {
            device_id: None,
            sample_rate: 48000,
            channels: 2,
        };

        let result = AppleAudioCaptureProcessor::from_config(config);

        match result {
            Ok(processor) => {
                // Note: from_config() doesn't call setup(), so device_info, sample_rate,
                // and channels are not yet initialized. This test just verifies that
                // from_config() succeeds with default config.
                println!("Successfully created audio capture processor from config");
            }
            Err(e) => {
                println!("Note: Could not create audio capture (may require permissions): {}", e);
            }
        }
    }

    #[test]
    fn test_capture_audio() {
        let config = AppleAudioCaptureConfig::default();
        let result = AppleAudioCaptureProcessor::from_config(config);

        if let Ok(mut processor) = result {
            std::thread::sleep(std::time::Duration::from_millis(100));

            let result = processor.process();
            if result.is_ok() {
                println!("Successfully processed captured audio");

                let level = processor.current_level();
                println!("Current audio level: {:.3}", level);
                assert!(level >= 0.0 && level <= 1.0);
            } else {
                println!("Note: Audio processing returned: {:?}", result);
            }
        } else {
            println!("Note: Could not create audio capture (may require permissions)");
        }
    }
}
