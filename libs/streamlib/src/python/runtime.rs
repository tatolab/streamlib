
use pyo3::prelude::*;
use pyo3::types::PyDict;
use super::error::PyStreamError;
use super::port::ProcessorPort;
use super::decorators::ProcessorProxy;
use std::sync::Arc;
use parking_lot::Mutex;
use crate::StreamRuntime;
use crate::core::{ProcessorHandle, VideoFrame};

#[cfg(any(target_os = "macos", target_os = "ios"))]
use crate::apple::{AppleCameraProcessor, AppleDisplayProcessor};

#[cfg(any(target_os = "macos", target_os = "ios"))]
use crate::apple::processors::camera::AppleCameraConfig;

#[cfg(any(target_os = "macos", target_os = "ios"))]
use crate::apple::processors::display::AppleDisplayConfig;

/// Python-facing processor handle that provides port access methods
#[pyclass(module = "streamlib", name = "ProcessorHandle")]
pub struct PyProcessorHandle {
    /// Unique processor ID (auto-generated by runtime)
    id: String,
}

#[pymethods]
impl PyProcessorHandle {
    /// Get the unique processor ID
    fn id(&self) -> String {
        self.id.clone()
    }

    /// Get an output port by name
    fn output_port(&self, port_name: String) -> ProcessorPort {
        ProcessorPort::create(self.id.clone(), port_name, false)
    }

    /// Get an input port by name
    fn input_port(&self, port_name: String) -> ProcessorPort {
        ProcessorPort::create(self.id.clone(), port_name, true)
    }

    fn __repr__(&self) -> String {
        format!("ProcessorHandle(id={})", self.id)
    }
}


#[pyclass(name = "StreamRuntime", module = "streamlib")]
pub struct PyStreamRuntime {
    runtime: Option<StreamRuntime>,
    processors: Arc<Mutex<Vec<Py<ProcessorProxy>>>>,
    connections: Arc<Mutex<Vec<(ProcessorPort, ProcessorPort)>>>,
}

#[pymethods]
impl PyStreamRuntime {
    #[new]
    fn new() -> Self {
        let runtime = StreamRuntime::new();

        Self {
            runtime: Some(runtime),
            processors: Arc::new(Mutex::new(Vec::new())),
            connections: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Add a processor to the runtime
    ///
    /// Supports both built-in processors (by type string/constant) and custom Python processors (via decorator).
    ///
    /// # Built-in Processors (no decorators needed):
    /// ```python
    /// from streamlib import CAMERA_PROCESSOR, DISPLAY_PROCESSOR
    ///
    /// camera = runtime.add_processor(
    ///     processor=CAMERA_PROCESSOR,
    ///     config={"device_id": "..."}
    /// )
    ///
    /// display = runtime.add_processor(
    ///     processor=DISPLAY_PROCESSOR,
    ///     config={"width": 1920, "height": 1080}
    /// )
    /// ```
    ///
    /// # Custom Python Processors (with decorator):
    /// ```python
    /// @processor(description="My custom processor")
    /// class MyProcessor:
    ///     def process(self):
    ///         ...
    ///
    /// my_proc = runtime.add_processor(processor=MyProcessor, config={...})
    /// ```
    #[pyo3(signature = (*, processor, config=None))]
    fn add_processor(
        &self,
        py: Python<'_>,
        processor: PyObject,
        config: Option<Py<PyDict>>,
    ) -> PyResult<Py<PyProcessorHandle>> {
        let proc_arg = processor;

        let mut processors_lock = self.processors.lock();
        let processor_index = processors_lock.len();

        // Generate unique ID (matches Rust runtime pattern)
        let id = format!("processor_{}", processor_index);

        // Check if it's a string (built-in processor type) or ProcessorProxy (decorated class)
        if let Ok(proc_type_str) = proc_arg.extract::<String>(py) {
            // Built-in processor by type string
            let (input_ports, output_ports) = match proc_type_str.as_str() {
                "CameraProcessor" => (vec![], vec!["video".to_string()]),
                "DisplayProcessor" => (vec!["video".to_string()], vec![]),
                _ => return Err(PyStreamError::Runtime(
                    format!("Unknown built-in processor type: {}. Available: CameraProcessor, DisplayProcessor", proc_type_str)
                ).into()),
            };

            let proxy = Py::new(py, ProcessorProxy {
                processor_name: id.clone(),
                processor_type: proc_type_str.clone(),
                config,
                python_class: None,
                input_port_names: input_ports,
                output_port_names: output_ports,
                description: None,
                usage_context: None,
                tags: Vec::new(),
            })?;

            processors_lock.push(proxy);
            tracing::info!("Added built-in processor '{}' with ID: {}", proc_type_str, id);

        } else if let Ok(proxy) = proc_arg.extract::<Py<ProcessorProxy>>(py) {
            // Custom Python processor (decorated)
            let mut processor_ref = proxy.borrow_mut(py);
            let processor_name = processor_ref.processor_name.clone();

            // Update config if provided
            if let Some(new_config) = config {
                processor_ref.config = Some(new_config);
            }

            drop(processor_ref);
            processors_lock.push(proxy.clone_ref(py));
            tracing::info!("Added custom processor '{}' with ID: {}", processor_name, id);

        } else {
            return Err(PyStreamError::Runtime(
                "processor must be either a processor type string (e.g., CAMERA_PROCESSOR) or a decorated processor class".to_string()
            ).into());
        }

        drop(processors_lock);

        // Create and return handle with unique ID
        let handle = Py::new(py, PyProcessorHandle {
            id,
        })?;

        Ok(handle)
    }

    /// Connect two processor ports
    ///
    /// Keyword-only arguments for explicit, readable connections:
    /// ```python
    /// runtime.connect(
    ///     output=camera.output_port("video"),
    ///     input=display.input_port("video")
    /// )
    /// ```
    #[pyo3(signature = (*, output, input))]
    fn connect(
        &self,
        output: ProcessorPort,
        input: ProcessorPort,
    ) -> PyResult<()> {
        let src = output;
        let dst = input;

        if src.is_input {
            return Err(PyStreamError::Connection(
                "Source/output port must be an output port".to_string()
            ).into());
        }
        if !dst.is_input {
            return Err(PyStreamError::Connection(
                "Destination/input port must be an input port".to_string()
            ).into());
        }

        let mut connections = self.connections.lock();
        connections.push((src, dst));

        Ok(())
    }

    fn run(&mut self, py: Python<'_>) -> PyResult<()> {
        println!("ðŸŽ¥ StreamRuntime starting...");

        let processors = self.processors.lock();
        println!("   Processors: {}", processors.len());

        let connections = self.connections.lock();
        println!("   Connections: {}", connections.len());

        let mut runtime = self.runtime.take().ok_or_else(|| {
            PyStreamError::Runtime("Runtime already started".to_string())
        })?;

        #[cfg(any(target_os = "macos", target_os = "ios"))]
        {
            use std::collections::HashMap;

            // Store processor handles - ALL processors get handles via add_processor_with_config
            let mut processor_handles: HashMap<String, ProcessorHandle> = HashMap::new();

            for proxy in processors.iter() {
                let proxy_ref = proxy.borrow(py);
                let processor_type = &proxy_ref.processor_type;
                let processor_name = &proxy_ref.processor_name;
                let config = &proxy_ref.config;

                match processor_type.as_str() {
                    "CameraProcessor" => {
                        println!("   Creating CameraProcessor: {}", processor_name);

                        let device_id = config.as_ref()
                            .and_then(|c| c.bind(py).get_item("device_id").ok().flatten())
                            .and_then(|v| v.extract::<String>().ok());

                        let camera_config = AppleCameraConfig {
                            device_id,
                        };

                        let handle = runtime.add_processor_with_config::<AppleCameraProcessor>(camera_config)
                            .map_err(|e| PyStreamError::Runtime(format!("Failed to create camera: {}", e)))?;

                        processor_handles.insert(processor_name.clone(), handle);
                    }
                    "DisplayProcessor" => {
                        println!("   Creating DisplayProcessor: {}", processor_name);

                        let config_dict = config.as_ref().map(|c| c.bind(py));

                        let width = config_dict
                            .and_then(|c| c.get_item("width").ok().flatten())
                            .and_then(|v| v.extract::<u32>().ok())
                            .unwrap_or(1920);

                        let height = config_dict
                            .and_then(|c| c.get_item("height").ok().flatten())
                            .and_then(|v| v.extract::<u32>().ok())
                            .unwrap_or(1080);

                        let title = config_dict
                            .and_then(|c| c.get_item("title").ok().flatten())
                            .and_then(|v| v.extract::<String>().ok());

                        let display_config = AppleDisplayConfig {
                            width,
                            height,
                            title,
                        };

                        let handle = runtime.add_processor_with_config::<AppleDisplayProcessor>(display_config)
                            .map_err(|e| PyStreamError::Runtime(format!("Failed to create display: {}", e)))?;

                        processor_handles.insert(processor_name.clone(), handle);
                    }
                    "PythonProcessor" => {
                        println!("   Creating PythonProcessor: {}", processor_name);

                        let python_class = proxy_ref.python_class.as_ref()
                            .ok_or_else(|| PyStreamError::Runtime("PythonProcessor missing python_class".to_string()))?
                            .clone_ref(py);

                        // TODO(@jonathan): ProcessorProxy should store PortMetadata from decorators
                        // For now, create basic metadata from port names (assume VideoFrame type)
                        use super::processor::{PortMetadata, FrameType, PythonProcessorConfig};
                        let input_metadata: Vec<PortMetadata> = proxy_ref.input_port_names.iter()
                            .map(|name| PortMetadata {
                                name: name.clone(),
                                frame_type: FrameType::Video, // TODO: get from decorators
                                description: String::new(),
                                required: true,
                            })
                            .collect();

                        let output_metadata: Vec<PortMetadata> = proxy_ref.output_port_names.iter()
                            .map(|name| PortMetadata {
                                name: name.clone(),
                                frame_type: FrameType::Video, // TODO: get from decorators
                                description: String::new(),
                                required: false,
                            })
                            .collect();

                        let config = PythonProcessorConfig {
                            python_class,
                            name: processor_name.clone(),
                            input_metadata,
                            output_metadata,
                            description: proxy_ref.description.clone(),
                            usage_context: proxy_ref.usage_context.clone(),
                            tags: proxy_ref.tags.clone(),
                        };

                        // Use the proper API - get a handle just like Camera/Display!
                        let handle = runtime.add_processor_with_config::<super::processor::PythonProcessor>(config)
                            .map_err(|e| PyStreamError::Runtime(format!("Failed to create Python processor: {}", e)))?;

                        processor_handles.insert(processor_name.clone(), handle);
                    }
                    _ => {
                        return Err(PyStreamError::Runtime(
                            format!("Unknown processor type: {}", processor_type)
                        ).into());
                    }
                }
            }

            println!("   Wiring {} connections...", connections.len());
            for (source_port, dest_port) in connections.iter() {
                println!("      {} â†’ {}",
                    format!("{}.{}", source_port.processor_name, source_port.port_name),
                    format!("{}.{}", dest_port.processor_name, dest_port.port_name)
                );

                let source_handle = processor_handles.get(&source_port.processor_name)
                    .ok_or_else(|| PyStreamError::Connection(
                        format!("Source processor '{}' not found", source_port.processor_name)
                    ))?;

                let dest_handle = processor_handles.get(&dest_port.processor_name)
                    .ok_or_else(|| PyStreamError::Connection(
                        format!("Destination processor '{}' not found", dest_port.processor_name)
                    ))?;

                // All connections now use the handle-based API!
                // TODO: Support different frame types (currently assumes VideoFrame)
                runtime.connect(
                    source_handle.output_port::<VideoFrame>(&source_port.port_name),
                    dest_handle.input_port::<VideoFrame>(&dest_port.port_name),
                ).map_err(|e| PyStreamError::Connection(format!("Failed to connect: {}", e)))?;
            }

            drop(processors);
            drop(connections);

            println!("   All processors added to runtime via add_processor_with_config");
        }

        println!("âœ… Processors instantiated");
        println!("ðŸš€ Starting runtime...\n");

        // Note: macOS event loop is already configured by StreamRuntime::new()

        py.allow_threads(|| {
            // Runtime.run() is now synchronous and blocks until shutdown
            runtime.run()
                .map_err(|e| PyStreamError::Runtime(format!("Runtime error: {}", e)))?;

            Ok(())
        })
    }

    fn __repr__(&self) -> String {
        let processors = self.processors.lock();
        let connections = self.connections.lock();
        format!(
            "StreamRuntime(processors={}, connections={})",
            processors.len(), connections.len()
        )
    }
}
