// Copyright (c) 2025 Jonathan Fontanez
// SPDX-License-Identifier: BUSL-1.1

//! Processor Pause/Resume Integration Tests
//!
//! Tests the per-processor and runtime-level pause/resume functionality:
//! 1. Pause stops frame flow, resume restarts it
//! 2. PubSub notifications on pause/resume
//! 3. Delegate rejection keeps flow going
//! 4. Runtime-level pause/resume affects all processors
//!
//! NOTE: Tests use #[serial] to avoid counter interference between tests.

use parking_lot::Mutex;
use serde::{Deserialize, Serialize};
use serial_test::serial;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use streamlib::core::delegates::ProcessorDelegate;
use streamlib::core::frames::{AudioChannelCount, AudioFrame};
use streamlib::core::graph::NodeIndex;
use streamlib::core::pubsub::{topics, Event, EventListener, ProcessorEvent, PUBSUB};
use streamlib::core::runtime::{CommitMode, StreamRuntime};
use streamlib::core::{LinkInput, LinkOutput, Result, RuntimeContext, StreamError};

// =============================================================================
// Test Counters
// =============================================================================

/// Counter for tracking frames generated by producer
static PRODUCER_FRAMES_GENERATED: AtomicU64 = AtomicU64::new(0);
/// Counter for tracking frames received by consumer
static CONSUMER_FRAMES_RECEIVED: AtomicU64 = AtomicU64::new(0);
/// Counter for tracking process() calls on consumer
static CONSUMER_PROCESS_CALLS: AtomicU64 = AtomicU64::new(0);
/// Counter for tracking iterations in manual processor
static MANUAL_ITERATIONS: AtomicU64 = AtomicU64::new(0);
/// Flag to stop the manual processor's internal loop
static MANUAL_STOP_FLAG: AtomicBool = AtomicBool::new(false);

use std::sync::atomic::AtomicBool;

fn reset_counters() {
    PRODUCER_FRAMES_GENERATED.store(0, Ordering::SeqCst);
    CONSUMER_FRAMES_RECEIVED.store(0, Ordering::SeqCst);
    CONSUMER_PROCESS_CALLS.store(0, Ordering::SeqCst);
    MANUAL_ITERATIONS.store(0, Ordering::SeqCst);
    MANUAL_STOP_FLAG.store(false, Ordering::SeqCst);
}

fn manual_iterations() -> u64 {
    MANUAL_ITERATIONS.load(Ordering::SeqCst)
}

fn producer_frames() -> u64 {
    PRODUCER_FRAMES_GENERATED.load(Ordering::SeqCst)
}

fn consumer_frames() -> u64 {
    CONSUMER_FRAMES_RECEIVED.load(Ordering::SeqCst)
}

#[allow(dead_code)]
fn consumer_process_calls() -> u64 {
    CONSUMER_PROCESS_CALLS.load(Ordering::SeqCst)
}

// =============================================================================
// Test Processors
// =============================================================================

// -----------------------------------------------------------------------------
// ProducerProcessor - Generates frames continuously
// -----------------------------------------------------------------------------

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ProducerConfig {
    pub label: String,
}

#[streamlib::processor(
    execution = Continuous,
    description = "Produces test frames continuously",
    unsafe_send
)]
pub struct ProducerProcessor {
    #[streamlib::output(description = "Output frames")]
    output: Arc<LinkOutput<AudioFrame>>,

    #[streamlib::config]
    config: ProducerConfig,
}

impl ProducerProcessor::Processor {
    fn setup(&mut self, _ctx: &RuntimeContext) -> Result<()> {
        Ok(())
    }

    fn teardown(&mut self) -> Result<()> {
        Ok(())
    }

    fn process(&mut self) -> Result<()> {
        // Generate a frame
        let samples = vec![0.0f32; 480];
        let frame = AudioFrame::new(
            samples,
            AudioChannelCount::One,
            0, // timestamp
            PRODUCER_FRAMES_GENERATED.load(Ordering::SeqCst),
            48000,
        );
        self.output.write(frame);
        PRODUCER_FRAMES_GENERATED.fetch_add(1, Ordering::SeqCst);
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// ConsumerProcessor - Receives frames reactively
// -----------------------------------------------------------------------------

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ConsumerConfig {
    pub label: String,
}

#[streamlib::processor(
    execution = Reactive,
    description = "Consumes test frames reactively",
    unsafe_send
)]
pub struct ConsumerProcessor {
    #[streamlib::input(description = "Input frames")]
    input: LinkInput<AudioFrame>,

    #[streamlib::config]
    config: ConsumerConfig,
}

impl ConsumerProcessor::Processor {
    fn setup(&mut self, _ctx: &RuntimeContext) -> Result<()> {
        Ok(())
    }

    fn teardown(&mut self) -> Result<()> {
        Ok(())
    }

    fn process(&mut self) -> Result<()> {
        CONSUMER_PROCESS_CALLS.fetch_add(1, Ordering::SeqCst);
        while let Some(_frame) = self.input.read() {
            CONSUMER_FRAMES_RECEIVED.fetch_add(1, Ordering::SeqCst);
        }
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// ManualProcessor - Runs its own loop, checks is_paused()
// -----------------------------------------------------------------------------

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ManualConfig {
    pub label: String,
}

#[streamlib::processor(
    execution = Manual,
    description = "Manual processor that manages its own loop",
    unsafe_send
)]
pub struct ManualProcessor {
    #[streamlib::output(description = "Output frames")]
    output: Arc<LinkOutput<AudioFrame>>,

    #[streamlib::config]
    config: ManualConfig,

    // Store runtime context for pause checking
    runtime_context: Option<Arc<RuntimeContext>>,
}

impl ManualProcessor::Processor {
    fn setup(&mut self, ctx: &RuntimeContext) -> Result<()> {
        // Store the runtime context for pause checking in our loop
        self.runtime_context = Some(Arc::new(ctx.clone()));
        Ok(())
    }

    fn teardown(&mut self) -> Result<()> {
        Ok(())
    }

    fn process(&mut self) -> Result<()> {
        // Manual processors run their own loop - spawn a thread that checks is_paused()
        let ctx = self.runtime_context.clone();
        let output = Arc::clone(&self.output);

        std::thread::spawn(move || {
            while !MANUAL_STOP_FLAG.load(Ordering::SeqCst) {
                // Check if paused via RuntimeContext
                if let Some(ref ctx) = ctx {
                    if ctx.is_paused() {
                        // Paused - skip work, just sleep
                        std::thread::sleep(Duration::from_millis(5));
                        continue;
                    }
                }

                // Not paused - do work
                let samples = vec![0.0f32; 480];
                let frame = AudioFrame::new(
                    samples,
                    AudioChannelCount::One,
                    0,
                    MANUAL_ITERATIONS.load(Ordering::SeqCst),
                    48000,
                );
                output.write(frame);
                MANUAL_ITERATIONS.fetch_add(1, Ordering::SeqCst);

                std::thread::sleep(Duration::from_millis(1));
            }
        });

        Ok(())
    }
}

// =============================================================================
// Test Delegate - Can reject pause/resume
// =============================================================================

// Note: RejectAllPausesDelegate is defined inline in test_delegate_rejection_prevents_pause
// to avoid needing a configurable delegate that predicts processor IDs.

// =============================================================================
// Test Event Listener - Tracks pause/resume events
// =============================================================================

struct PauseResumeEventListener {
    pause_count: AtomicU64,
    resume_count: AtomicU64,
}

impl PauseResumeEventListener {
    fn new() -> Self {
        Self {
            pause_count: AtomicU64::new(0),
            resume_count: AtomicU64::new(0),
        }
    }

    fn pause_count(&self) -> u64 {
        self.pause_count.load(Ordering::SeqCst)
    }

    fn resume_count(&self) -> u64 {
        self.resume_count.load(Ordering::SeqCst)
    }
}

impl EventListener for PauseResumeEventListener {
    fn on_event(&mut self, event: &Event) -> Result<()> {
        if let Event::ProcessorEvent { event, .. } = event {
            match event {
                ProcessorEvent::Paused => {
                    self.pause_count.fetch_add(1, Ordering::SeqCst);
                }
                ProcessorEvent::Resumed => {
                    self.resume_count.fetch_add(1, Ordering::SeqCst);
                }
                _ => {}
            }
        }
        Ok(())
    }
}

// =============================================================================
// Tests
// =============================================================================

/// Test that pausing a Continuous processor stops frame generation
#[test]
#[serial]
fn test_pause_stops_continuous_processor() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    // Add producer (Continuous mode)
    let producer = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer".to_string(),
        })
        .expect("Failed to add producer");

    // Start the runtime
    runtime.start().expect("Failed to start runtime");

    // Let it generate some frames
    std::thread::sleep(Duration::from_millis(50));
    let frames_before_pause = producer_frames();
    assert!(
        frames_before_pause > 0,
        "Producer should have generated frames"
    );

    // Pause the producer
    runtime
        .pause_processor(&producer)
        .expect("Failed to pause producer");

    // Verify processor is paused
    assert!(
        runtime.is_processor_paused(&producer).unwrap(),
        "Producer should be paused"
    );

    // Wait and check that no more frames are generated
    let frames_at_pause = producer_frames();
    std::thread::sleep(Duration::from_millis(50));
    let frames_after_pause = producer_frames();

    // Should have stopped (or at most 1-2 frames in flight)
    assert!(
        frames_after_pause <= frames_at_pause + 2,
        "Producer should stop generating frames when paused. Before: {}, After: {}",
        frames_at_pause,
        frames_after_pause
    );

    // Resume and verify frames start flowing again
    runtime
        .resume_processor(&producer)
        .expect("Failed to resume producer");

    assert!(
        !runtime.is_processor_paused(&producer).unwrap(),
        "Producer should not be paused"
    );

    std::thread::sleep(Duration::from_millis(50));
    let frames_after_resume = producer_frames();
    assert!(
        frames_after_resume > frames_after_pause + 5,
        "Producer should resume generating frames. At pause: {}, After resume: {}",
        frames_after_pause,
        frames_after_resume
    );

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}

/// Test that pausing a Reactive processor stops it from processing incoming data
#[test]
#[serial]
fn test_pause_stops_reactive_processor() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    // Add producer and consumer
    let producer = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer".to_string(),
        })
        .expect("Failed to add producer");

    let consumer = runtime
        .add_processor::<ConsumerProcessor::Processor>(ConsumerConfig {
            label: "consumer".to_string(),
        })
        .expect("Failed to add consumer");

    // Connect them using string format
    runtime
        .connect(
            format!("{}.output", producer),
            format!("{}.input", consumer),
        )
        .expect("Failed to connect");

    // Start the runtime
    runtime.start().expect("Failed to start runtime");

    // Let some frames flow
    std::thread::sleep(Duration::from_millis(50));
    let received_before_pause = consumer_frames();
    assert!(
        received_before_pause > 0,
        "Consumer should have received frames"
    );

    // Pause the consumer
    runtime
        .pause_processor(&consumer)
        .expect("Failed to pause consumer");

    // Wait and check that consumer stops receiving
    let received_at_pause = consumer_frames();
    std::thread::sleep(Duration::from_millis(50));
    let received_after_pause = consumer_frames();

    // Consumer should have stopped (producer continues but consumer doesn't process)
    assert!(
        received_after_pause <= received_at_pause + 2,
        "Consumer should stop receiving when paused. At pause: {}, After: {}",
        received_at_pause,
        received_after_pause
    );

    // Resume and verify frames start flowing again
    runtime
        .resume_processor(&consumer)
        .expect("Failed to resume consumer");

    std::thread::sleep(Duration::from_millis(50));
    let received_after_resume = consumer_frames();
    assert!(
        received_after_resume > received_after_pause,
        "Consumer should resume receiving. At pause: {}, After resume: {}",
        received_after_pause,
        received_after_resume
    );

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}

/// Test that pubsub notifications are sent on pause/resume
#[test]
#[serial]
fn test_pubsub_notifications_on_pause_resume() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    // Add producer
    let producer = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer".to_string(),
        })
        .expect("Failed to add producer");

    // Subscribe to processor events
    let listener = Arc::new(Mutex::new(PauseResumeEventListener::new()));
    PUBSUB.subscribe(
        &topics::processor(&producer),
        Arc::clone(&listener) as Arc<Mutex<dyn EventListener>>,
    );

    // Start
    runtime.start().expect("Failed to start runtime");
    std::thread::sleep(Duration::from_millis(20));

    // Pause - should trigger Paused event
    runtime.pause_processor(&producer).expect("Failed to pause");
    std::thread::sleep(Duration::from_millis(10)); // Give event time to propagate

    assert_eq!(
        listener.lock().pause_count(),
        1,
        "Should have received Paused event"
    );
    assert_eq!(
        listener.lock().resume_count(),
        0,
        "Should not have received Resumed event yet"
    );

    // Resume - should trigger Resumed event
    runtime
        .resume_processor(&producer)
        .expect("Failed to resume");
    std::thread::sleep(Duration::from_millis(10));

    assert_eq!(
        listener.lock().pause_count(),
        1,
        "Should still have 1 Paused event"
    );
    assert_eq!(
        listener.lock().resume_count(),
        1,
        "Should have received Resumed event"
    );

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}

/// Test that delegate rejection prevents pause
#[test]
#[serial]
fn test_delegate_rejection_prevents_pause() {
    reset_counters();

    // Create a delegate that rejects ALL pause requests
    struct RejectAllPausesDelegate;

    impl ProcessorDelegate for RejectAllPausesDelegate {
        fn will_pause(&self, id: &str) -> Result<()> {
            Err(StreamError::Runtime(format!(
                "Pause rejected for processor '{}'",
                id
            )))
        }
    }

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .with_processor_delegate(RejectAllPausesDelegate)
        .build();

    let producer = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer".to_string(),
        })
        .expect("Failed to add producer");

    runtime.start().expect("Failed to start runtime");
    std::thread::sleep(Duration::from_millis(30));

    let frames_before = producer_frames();

    // Try to pause - should fail due to delegate rejection
    let result = runtime.pause_processor(&producer);
    assert!(result.is_err(), "Pause should be rejected by delegate");

    // Verify processor is NOT paused
    assert!(
        !runtime.is_processor_paused(&producer).unwrap(),
        "Producer should not be paused after rejection"
    );

    // Verify frames continue flowing
    std::thread::sleep(Duration::from_millis(30));
    let frames_after = producer_frames();
    assert!(
        frames_after > frames_before + 5,
        "Frames should continue flowing after rejected pause. Before: {}, After: {}",
        frames_before,
        frames_after
    );

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}

/// Test runtime-level pause/resume affects all processors
#[test]
#[serial]
fn test_runtime_pause_resume_all_processors() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    // Add multiple producers
    let producer1 = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer1".to_string(),
        })
        .expect("Failed to add producer1");

    let producer2 = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer2".to_string(),
        })
        .expect("Failed to add producer2");

    // Start
    runtime.start().expect("Failed to start runtime");
    std::thread::sleep(Duration::from_millis(50));

    let frames_before = producer_frames();
    assert!(frames_before > 0, "Should have generated frames");

    // Pause entire runtime
    runtime.pause().expect("Failed to pause runtime");

    // Verify both processors are paused
    assert!(
        runtime.is_processor_paused(&producer1).unwrap(),
        "Producer1 should be paused"
    );
    assert!(
        runtime.is_processor_paused(&producer2).unwrap(),
        "Producer2 should be paused"
    );

    // Verify no more frames generated
    let frames_at_pause = producer_frames();
    std::thread::sleep(Duration::from_millis(50));
    let frames_after_pause = producer_frames();
    assert!(
        frames_after_pause <= frames_at_pause + 4, // Allow some in-flight
        "Should stop generating frames. At pause: {}, After: {}",
        frames_at_pause,
        frames_after_pause
    );

    // Resume entire runtime
    runtime.resume().expect("Failed to resume runtime");

    // Verify both processors are resumed
    assert!(
        !runtime.is_processor_paused(&producer1).unwrap(),
        "Producer1 should not be paused"
    );
    assert!(
        !runtime.is_processor_paused(&producer2).unwrap(),
        "Producer2 should not be paused"
    );

    // Verify frames flowing again
    std::thread::sleep(Duration::from_millis(50));
    let frames_after_resume = producer_frames();
    assert!(
        frames_after_resume > frames_after_pause + 5,
        "Should resume generating. After pause: {}, After resume: {}",
        frames_after_pause,
        frames_after_resume
    );

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}

/// Test idempotent pause/resume (calling twice is no-op)
#[test]
#[serial]
fn test_pause_resume_idempotent() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    let producer = runtime
        .add_processor::<ProducerProcessor::Processor>(ProducerConfig {
            label: "producer".to_string(),
        })
        .expect("Failed to add producer");

    runtime.start().expect("Failed to start runtime");

    // Pause twice - second should be no-op
    runtime.pause_processor(&producer).expect("First pause");
    runtime
        .pause_processor(&producer)
        .expect("Second pause should succeed (no-op)");

    assert!(runtime.is_processor_paused(&producer).unwrap());

    // Resume twice - second should be no-op
    runtime.resume_processor(&producer).expect("First resume");
    runtime
        .resume_processor(&producer)
        .expect("Second resume should succeed (no-op)");

    assert!(!runtime.is_processor_paused(&producer).unwrap());

    runtime.stop().expect("Failed to stop runtime");
}

/// Test that Manual mode processors can check is_paused() via RuntimeContext
#[test]
#[serial]
fn test_manual_processor_checks_is_paused() {
    reset_counters();

    let mut runtime = StreamRuntime::builder()
        .with_commit_mode(CommitMode::BatchAutomatically)
        .build();

    // Add manual processor
    let manual = runtime
        .add_processor::<ManualProcessor::Processor>(ManualConfig {
            label: "manual".to_string(),
        })
        .expect("Failed to add manual processor");

    // Start the runtime
    runtime.start().expect("Failed to start runtime");

    // Let it generate some iterations
    std::thread::sleep(Duration::from_millis(50));
    let iterations_before_pause = manual_iterations();
    assert!(
        iterations_before_pause > 0,
        "Manual processor should have run some iterations"
    );

    // Pause the manual processor
    runtime
        .pause_processor(&manual)
        .expect("Failed to pause manual processor");

    // Verify processor is paused
    assert!(
        runtime.is_processor_paused(&manual).unwrap(),
        "Manual processor should be paused"
    );

    // Wait and check that iterations stop
    let iterations_at_pause = manual_iterations();
    std::thread::sleep(Duration::from_millis(50));
    let iterations_after_pause = manual_iterations();

    // Should have stopped (or at most a few in-flight)
    assert!(
        iterations_after_pause <= iterations_at_pause + 5,
        "Manual processor should stop iterating when paused. At pause: {}, After: {}",
        iterations_at_pause,
        iterations_after_pause
    );

    // Resume and verify iterations restart
    runtime
        .resume_processor(&manual)
        .expect("Failed to resume manual processor");

    assert!(
        !runtime.is_processor_paused(&manual).unwrap(),
        "Manual processor should not be paused"
    );

    std::thread::sleep(Duration::from_millis(50));
    let iterations_after_resume = manual_iterations();
    assert!(
        iterations_after_resume > iterations_after_pause + 5,
        "Manual processor should resume iterating. At pause: {}, After resume: {}",
        iterations_after_pause,
        iterations_after_resume
    );

    // Stop the manual processor's internal loop
    MANUAL_STOP_FLAG.store(true, Ordering::SeqCst);
    std::thread::sleep(Duration::from_millis(20)); // Let thread exit

    // Cleanup
    runtime.stop().expect("Failed to stop runtime");
}
